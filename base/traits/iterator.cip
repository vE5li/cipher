import $super::$super::Option
import $super::from::FromIterator

public trait Iterator<T> {

    public type Type

    public label next: Function(&self) -> Option<Type>
}

implement<T> Iterator<T> {

    public label cloned: Function($self) -> Self := {
        @ ...
    }

    public label for_each: Function(&self, function: Function(item: Type)) := {
        while case Some: item == self.next() {
            function(raw?(item))
        }
    }

    public label find: Function(&self, function: Function(item: Type) -> Option<Type>) := {
        while case Some: item == self.next() {
            if function($item) {
                return implied Some(raw?(item))
            }
        }
        return implied None
    }

    public label map: Function<R>(&self, function: Function(item: Type) -> R) -> HeapIterator<R> := {
        @ ...
    }

    public label enumerate: Function(&self) -> HeapIterator<(Type, Integer)> := {
        @ ...
    }

    public label collect<R: FromIterator>: Function(self) -> R {
        return R::from_iterator(self)
    }
}
