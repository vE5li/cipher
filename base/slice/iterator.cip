import super::super::iterator::Iterator

public structure SliceIterator<T> {
    slice: $Slice<T>
    index: Integer,
}

implement<T> SliceIterator<T> {

    public label new: Function(slice: $Slice<T>) -> Self {
        return implied?(slice, 0)
    }
}

implement<T> Iterator<T> for SliceIterator<T> {

    public type Type := $T

    public label next: Function(&self) -> Option<Type> := {

        if self.index == self.slice.length {
            return None
        }

        label item = $self.slice[self.index]
        self.index += 1
        return item
    }
}

public structure MutableSliceIterator<T> {
    slice: &Slice<T>
    index: Integer,
}

implement<T> MutableSliceIterator<T> {

    public label new: Function(slice: &Slice<T>) -> Self {
        return implied?(slice, 0)
    }
}

implement<T> Iterator<T> for MutableSliceIterator<T> {

    public type Type := &T

    public label next: Function(&self) -> Option<Type> := {

        if self.index == self.slice.length {
            return None
        }

        label item = &self.slice[self.index]
        self.index += 1
        return item
    }
}
